#Report

##pi.c
###Algorithm analysis
The algorithm runs in two main phases, one is serial and the other one is parallel.  
The serial part is initialisation. It consists of setting the number of threads wanted, creating a random number generator, and preparing a variable for the points that will land inside the circle. This part is executed once, and run therefore in O(1).

The parallel phase is the calculus phase and look like this :  

    #pragma omp parallel for
    for (size_t i = 0; i < samples; ++i) {
        double x = next_rand(rand);
        double y = next_rand(rand);
        if (x*x + y*y <= 1){
            #pragma omp atomic
            nb_points += 1;
        }
    }
For each samples needed, we generate two random numbers, representing the X and Y coordinates of a points. If the distance between the point and the origin is less than 1, it is in the circle, and need to be added to nb_points. It has to be done in an atomic manner, to avoid wrong updates of the value.  
As every iteration of the loop is independent, it is possible to run it in a parallel manner.