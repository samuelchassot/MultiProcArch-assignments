# Assignment 3

##Data races

####Two threads trying to insert a node in the same place
The list contains the elements 5 and 10, P0 is trying to insert element 7, and P1 want to insert 8. Both processors have created their nodes and the state of variables is as follows :

* **P0** : 	previous =  node(5), current = node(10)
* **P1** : 	previous =  node(5), current = node(10)

At some point the following sequence of events happens :

1. **P0** : new_node->next = current; 
2. **P1** : new_node->next = current;
3. **P0** : previous->next = new_node;
4. **P1** : previous->next = new_node;

The effect is that the list now only contains 5,8 and 10. A race between operations **3** and **4** resulted in a unexpected behavior of the list.

###One thread trying to add, one thread trying to delete

The list contains the elements 5, 8 and 10. P0 is executing insert(7) and P1 is executing delete(8).
Both processors have found the place where they will perform their operations, and the state of variables is as follows :

* **P0** : previous = node(5), current = node(8)
* **P1** : previous = node(5), current = node(8)

At some point the following sequence of events happens :

1. **P0** : new_node->next = current;
2. **P1** : previous->next = current->next;
3. **P0** : previous->next = new_node;

The effect is that the list now contains 5, 7, 8 and 10. Because of the race between op **2** and **3**, the list can behave as if the delete never occured. The *to_remove* flag on the node(8) is still set, and when it will effectively deleted, this can lead the unauthorized memory access.

###Two threads trying to delete two contiguous elements

The list contains the elements 5, 7, 8 and 10. P0 is executing delete(7) and P1 is executing delete(8).
Both processors have found the place where they will perform their operations, and the state of variables is as follows :

* **P0** : previous = node(5), current = node(7)
* **P1** : previous = node(7), current = node(8)

At some point the following sequence of events happens :

1. **P0** : previous->next = current->next;
2. **P1** : previous->next = current->next;

The effect is that the list now contains 5, 8 and 10.
Because **P1** wasn't aware that node(7) was deleted, it couldn't create the right link to delete 8. As before, an unauthorized memory access can occur, since 8 is still linked, but the *to_remove* flag is set.

###Search operations

As the search operations doens't modify anything in the list, no races can occur. As operations in two threads don't have any happens-before relationship, the behavior of search during an addition or a deletion is undefined. There is no way to ensure that the added/deleted element will be included/excluded from the search.

##Single lock
To simplify and shorten the code snippet, only relevant parts are mentioned. Comments indicate where code lines were omitted.

```C
omp_lock_t lock;
omp_init_lock(&lock);

int insert(node_t* head, int val) {
	omp_set_lock(&lock);
	//omitted code

	if (current && current->val == val) {
		omp_unset_lock(&lock);
        return -1;
    }
    
    //omitted code
    omp_unset_lock(&lock);
    return 0;
} 

int delete(node_t* head, int val) {
	omp_set_lock(&lock);
   	node_t *previous, *current;
	if (head->next == NULL) {
		omp_unset_lock(&lock);
      	return -1;
    }
	
	//omitted code
	if (current->val == val) {
		//omitted code
		omp_unset_lock(&lock);
		return val;
	}
	
	//omitted code
   
   omp_unset_lock(&lock); 
	return -1;

}
```

##Performance bottleneck

With a single lock, every operation on the list is done in a sequenstial way, and thus the benefits of parallelism is lost, even though we could add elements in two different places without introducing races.