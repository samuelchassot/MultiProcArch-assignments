# Assignment 2

## Optimizations
### Algorithm optimization
First of all, we observed that the grid can be cut into 4 symetrical parts like this :

*Here insert the image* 

The four parts are symetrical so we can compute for only one of them and then just populate the other with the same value but with a axial symetry. This leads to a gain in performance by a factor of 4. To do so we go through the array only to length/2-1 for height and width. 

### Parallelization
First we put the two *for loop* in parallel section. Then we add a padding to reduce the amount of false sharing. Since we only compute value for the quarter of the grid, we need less space in the arrays. We chose to add 3 empty spaces of the *sizeof(double)* between each value. This gives array of the size *length\*length\*4/4=length\*length*. *length\*length* is the size of the initial array so we multiplie it by 4 to have space for 4 times more double but we divide it by 4 because we only use the first quarter. We also rewrite macros to write in these new arrays :
```c
#define PINPUT(I,J) pInput[4*((I)*length+(J))]
#define POUTPUT(I,J) pOutput[4*((I)*length+(J))]
``` 
At the end we write what is inside *pOutput* in the *Output* array and at this moment, we write the value in 4 different places to populate the whole array using the symmetrical propterty.