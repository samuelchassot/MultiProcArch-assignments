# Assignment 2

## Optimizations
### Algorithm optimization
First of all, we observed that the grid can be cut into 8 symetrical parts like this :

<img src="schema.jpg" width=350>

The 8 parts are symetrical so we can compute for only one of them (the blue one on the) and then just populate the other with the same value but with a axial symetry. This leads to a gain in performance by a factor of 8. The only critical parts are when we compute the cells that are at the border. When we need a cell that is in a part that we do not compute, we just use its symetrical sister that is in the region. 

### Parallelization
First we put the two *for loop* in parallel section and the outer *for loop* in a *#pragma omp for parallel*. Then we try to add a padding to reduce the amount of false sharing. But it augments the execution time. To do the padding we had to copy both *input* and *output* arrays in two new arrays and add some empty spaces between each double. We allocate 8 times more space that the initial grid but only for the first quarter (because we only use this part during computation). This leads to an array size of : *(length/2)\*(length/2)\*8*. And access like this : *pOutput[8\*index]*.

But the problem is that we can't pad the arrays we receive so we need to work on others. And doing this we have to copy the array we used to compute in the ouput array we received as argument. This copy costs more than the cache misses we don't have anymore with this solution. Our program runs 3x slower when we use the padding.

Seeing that we decided to remove the padding because we are looking for the best performance.